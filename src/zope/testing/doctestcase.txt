Doctests in TestCase classes
============================

The original ``doctest`` unittest integration was based on
``unittest`` test suites, which have fallen out of favor. This module
provides a way to define doctests inside of unittest ``TestCase``
classes. It also provides better integration with unittest test
fixtures, because doctests use setup provided by the containing test
case class.

You can define doctests in 4 ways:

- references to named files

- strings

- decorated functions with docstrings

- reference to named files decorating test-specific setup functions

.. some setup

   >>> __name__ = 'tests'

Here are some examples::

    >>> import doctest
    >>> import unittest
    >>> from zope.testing.doctestcase import DocTest
    >>> class MyTest(unittest.TestCase):
    ...
    ...     def setUp(self):
    ...         self.a = 1
    ...
    ...     test1 = DocTest('test1.txt', optionflags=doctest.ELLIPSIS)
    ...
    ...     test2 = DocTest('''
    ...     >>> test.a
    ...     1
    ...     ''')
    ...
    ...     @DocTest(optionflags=doctest.ELLIPSIS)
    ...     def test3(self):
    ...         '''
    ...         >>> test.a, test.x
    ...         (1, 3)
    ...         '''
    ...         self.x = 3
    ...
    ...     @DocTest('test4.txt')
    ...     def test4(self):
    ...         self.x = 5

.. We can run these tests with the ``unittest`` test runner.

    >>> loader = unittest.TestLoader()
    >>> suite = loader.loadTestsFromTestCase(MyTest)
    >>> import sys
    >>> sys.stdout.writeln = lambda s: sys.stdout.write(s+'\n')
    >>> result = suite.run(unittest.TextTestResult(sys.stdout, True, 3))
    test1 (tests.MyTest) ... ok
    test2 (tests.MyTest) ... ok
    test3 (tests.MyTest) ... ok
    test4 (tests.MyTest) ... ok

The example illustrates some additional points:

- the test case ``self`` argument is exposed to the doctest as the
  ``test`` global variable.  This gives the test access to any
  attributes defined in the test case.

- The body of a function who's docstring defines a doctest is run before
  the test, providing test-specific setup, if desired.

- A the return value of the doctest function can be used to decorate a
  function.  The decorated function is run before the test is executed.
  This provides a way to provide some test-specfic setup, if desired.

  Note that the docstring, of any, of the decorated function is ignored.

Also note that, unlike regular unit tests, module globals from the
module defining the tests are't included in the test globals.

The DocTest constructor accepts standard ``optionflags`` and
``checker`` arguments.

.. Let's look at some failure cases:

    >>> class MyTest(unittest.TestCase):
    ...
    ...     test2 = DocTest('''
    ...     >>> 1
    ...     1
    ...     >>> 1 + 1
    ...     1
    ...     ''')
    ...
    ...     @DocTest
    ...     def test3(self):
    ...         '''
    ...         >>> test.x
    ...         3
    ...         >>> 1 + 1
    ...         1
    ...         '''
    ...         self.x = 3
    ...
    ...     @DocTest('test4f.txt')
    ...     def test4(self):
    ...         self.x = 5

    >>> suite = loader.loadTestsFromTestCase(MyTest)
    >>> result = suite.run(unittest.TextTestResult(sys.stdout, True, 1))
    FFF
    >>> for c, e in result.failures:
    ...     print(e) # doctest: +ELLIPSIS
    Traceback (most recent call last):
      ...
    ...DocTestFailureException: Failed doctest test for <string>
      File "<string>", line 0, in <string>
    <BLANKLINE>
    ----------------------------------------------------------------------
    File "<string>", line 4, in <string>
    Failed example:
        1 + 1
    Expected:
        1
    Got:
        2
    <BLANKLINE>
    <BLANKLINE>
    Traceback (most recent call last):
      ...
    ...DocTestFailureException: Failed doctest test for test3
      File "None", line 10, in test3
    <BLANKLINE>
    ----------------------------------------------------------------------
    Line 4, in test3
    Failed example:
        1 + 1
    Expected:
        1
    Got:
        2
    <BLANKLINE>
    <BLANKLINE>
    Traceback (most recent call last):
    ...
    ...DocTestFailureException: Failed doctest test for test4f.txt
      File "...test4f.txt", line 0, in txt
    <BLANKLINE>
    ----------------------------------------------------------------------
    File "...test4f.txt", line 3, in test4f.txt
    Failed example:
        1 + 1
    Expected:
        1
    Got:
        2
    <BLANKLINE>
    <BLANKLINE>

.. Verify setting optionflags and checker

    >>> class EasyChecker:
    ...     def check_output(self, want, got, optionflags):
    ...         return True
    ...     def output_difference(self, example, got, optionflags):
    ...         return ''

    >>> class MyTest(unittest.TestCase):
    ...
    ...     test2 = DocTest('''
    ...     >>> 1
    ...     2
    ...     ''', checker=EasyChecker())
    ...
    ...     @DocTest(optionflags=doctest.ELLIPSIS)
    ...     def test3(self):
    ...         '''
    ...         >>> 'Hello'
    ...         '...'
    ...         '''
    ...
    ...     @DocTest('test4e.txt', optionflags = doctest.ELLIPSIS)
    ...     def test4(self):
    ...         self.x = 5
    >>> suite = loader.loadTestsFromTestCase(MyTest)
    >>> result = suite.run(unittest.TextTestResult(sys.stdout, True, 2))
    test2 (tests.MyTest) ... ok
    test3 (tests.MyTest) ... ok
    test4 (tests.MyTest) ... ok
